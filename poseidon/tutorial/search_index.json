[
["index.html", "POSEIDON tutorial Chapter 1 Introduction", " POSEIDON tutorial Ernesto Carrella 2018-08-31 Chapter 1 Introduction This is a simple tutorial on using POSEIDON, a fishery agent-based model. You can read more about this project by reading its main paper or looking at the code repository. This guide will not explain or require any analysis of the java code. I try here to simply show what can be done by just using the graphical user interface and basic text editing. "],
["getting-started.html", "Chapter 2 Getting Started 2.1 Installation 2.2 Starting POSEIDON 2.3 The scenario selection screen", " Chapter 2 Getting Started 2.1 Installation 2.1.1 Pre-requisites Need to have Java JDK installed (version 8 at least); download here (optional) have git installed 2.1.2 Downloading POSEIDON 2.1.2.1 Option 1 : Download from git The best way to obtain POSEIDON is to download it from its repository. If you have git installed, a single command will do: git clone https://github.com/CarrKnight/POSEIDON.git On linux/mac this is done on terminal, on Windows this is done on git bash. 2.1.2.2 Option 2 : Download zip file You can download POSEIDON zipped from github here but you will not have access to the repository (so no updates without downloading everything one more time). 2.2 Starting POSEIDON POSEIDON is a gradle project which means (hopefully, anyway) that the library management and building are taken care of automatically. On linux/mac you should be able to simply call: ./gradlew run in the POSEIDON directory to start the program. On windows use gradlew.bat run The first time this is run, POSEIDON will download all the libraries it needs and build itself. If everything went well you should see something like this: Welcome to POSEIDON! 2.3 The scenario selection screen When you start POSEIDON you will be greeted by the scenario selection window: The radio buttons on the left select which scenario to run; for all the simulations in this tutorial we will stick with the abstract model. The main panel contains various parameters of the scenario we can modify And pressing “OK” will start the model proper "],
["basic-model-operation.html", "Chapter 3 Basic Model Operation 3.1 The first model run 3.2 POSEIDON in motion 3.3 Tracking and Inspecting Agents 3.4 Aggregate Data 3.5 Fishing Fronts", " Chapter 3 Basic Model Operation 3.1 The first model run Start POSEIDON by running on terminal: ./gradlew run You will be greeted by the scenario selection window: Keep the default scenario settings and press the OK button. The scenario selection dialog will disappear and be replaced by the controller window (which you should be familiar with if you have ever done any other MASON modelling) There are 3 buttons on the bottom left corner: play , , and . Pressing stop at any time will close the simulation and return to the scenario selection dialog. Pressing either play or pause will start the simulation. play will start the simulation and run it, while pause will start the simulation but wait for user input before doing anything else. Press to start the simulation. When the simulation starts, a second window will open containing the bathymetry of the simulation. Green areas represent land, blue areas represent the sea (the darker, the higher the depth). On the top-right corner you can change the mode of the bathymetry to show other geographical information. In the default abstract scenario there is a single species of fish (Species 0) randomly dispersed. As shown below we can check where it is more prevalent on the bathymetry (the darker the areas the more fish is in that cell). 3.2 POSEIDON in motion Press to run the simulation. Let’s run it for a couple of simulated years. The simulated time is written down at the bottom of the controller. If you look at the bathymetry you can see something like this unfolding: This the “fishing front” behaviour we described in the paper. Basically fish is uniformly distributed but travel is expensive so agents quickly learn to fish near port for maximum profits. However these areas are consumed quickly and fishers fan out away from the port as time goes by. You can get investigate the effect by looking at the biomass layer to see that areas close to port are indeed depleted: 3.3 Tracking and Inspecting Agents If we want to track a particular boat over time we can single click it in the bathymetry simulation and we will be able to see its path as the simulation progresses. Press , single click on a boat and then press again to see its motion. Single click on an empty cell will turn off the tracking. We can also look at the variables of each agent to understand their behaviour. If we double click on a boat we can use the inspector tab to check its variables and understand its behaviour. These variables will update as the simulation continues. Press , double click on a boat and then look for its name in the Inspectors tab of the controller (it will say some variation of “Fisher X”). You will be able to look at all its variables (in alphabetical order) underneath. A particularly important set of variables are Daily Data and Yearly Data. These are the data collected by the individual fisher over time both for decision making and for us to monitor. Its variables are shown as buttons and clicking on any of them will open a time series describing its progression. Running the model while inspecting the variables of many agents is computationally expensive. When you are done observing, press Empty List to speed up POSEIDON. 3.4 Aggregate Data As we have seen, agents hold some data objects we can observe in the form of time series. The model itself is also collecting data on the whole fishery. These can be accessed in the Aggregate Data section of the controller. You may save the data to file by pressing to csv just next to the data button or you can save the time series image directly by right clicking on its picture and saving to PNG. 3.5 Fishing Fronts Run the model for about 10 years. Look at the Average Distance From Port daily aggregate data. It will clearly show (after the initial noise due to random starting conditions) a clear trend of fishing further and further out. Similarly, look at Average Last Trip Hourly Profits. You will see that the profitability of fishing decreasing steadily the first year and settling into a permanent low. However if you look at Biomass Species 0 you will see that the amount of fish in the sea has actually increased over the years. A quick glance at the bathymetry will reveal the problem. Areas far from port are brimming with fish, areas near port are depleted. While Average Hours Out is steady through the years, Effort (which in POSEIDON refers to actual hours fishing) drops by year 2. That is, fishers spend a lot more time travelling back and forth instead of fishing. "],
["changing-basic-parameters.html", "Chapter 4 Changing Basic Parameters 4.1 Types of parameters 4.2 Larger fishing fronts", " Chapter 4 Changing Basic Parameters 4.1 Types of parameters Each POSEIDON run is defined by a scenario and its parameters. Broadly, a scenario defines the order in which things are created, the parameter defines what is actually there. Start POSEIDON (or press if it was running before). The first screen is the scenario selection dialog. The main frame of the dialog is the alphabetical list of all the parameters in the scenario. Some parameters are simple, ticking a boolean true or false for example. Other parameters are numerical. These can be modified both in terms of their value and their random distribution if so desired. A few others are complex and they are made by multiple parameters. For example the way agents decide their location. In this case there is a drop-down menu whose selection is itself made of other parameters (some which may also be complex). 4.2 Larger fishing fronts For this run let’s just modify the number of fishers from 100 to 300; this can be done by simply changing the Fishers parameter to 300. Let’s also increase the maximum capacity of the vessel from 100 to 300; to do this change the Hold Size parameter from 100 to 300. Let’s start and run the model for 3 years. Graphically we can see again the fishing front in operation. In this scenario however the fishing front does not reach an equilibrium. It expands until it consumes the entirety of the ocean. Run the model for 10 years. Look at 2 aggregate data columns: Biomass Species 0 and Average Cash-Flow. Make sure they tell the same collapse story. "],
["map.html", "Chapter 5 Change the base map 5.1 Load a realistic map 5.2 Download other maps", " Chapter 5 Change the base map 5.1 Load a realistic map Start POSEIDON. One parameter of the abstract scenario is the Map Initializer. This controls the basic geography of the scenario. Most applications of POSEIDON will involve loading a map from an external file. Let’s do so here by selecting From File Map as the Map Initializer. There are 4 parameters to From File Map: Map File: which is merely the path to the .csv file containing the bathymetry Grid Width in Cell: this is how many cells in POSEIDON will the csv map be subdivided in. For example, if we leave 100 as default the map will be a grid of width 100 (and the height proportional to the heigth-width ratio of the input). Header which is true if the csv file has a non numeric first row Lat Long which is true when the original map’s coordinates are lat-long; when this is false the coordinates are assumed UTM. Lat-long coordinates might result in slightly slower models because the distance function involves a couple of trigonometric functions. However UTM often involves large space distortions. The Map File is simply a long list of \\(x\\) and \\(y\\) coordinates followed by an altitude reading (negative means underwater). ## x y depth ## 1 105.04 0 -31.00 ## 2 105.13 0 -31.00 ## 3 105.22 0 -32.91 ## 4 105.31 0 -35.81 ## 5 105.40 0 -37.00 POSEIDON will act at a coarser resolution than what is present in the input file. The depth of a cell in POSEIDON will be the average depth of all rows the csv file that are assigned to that POSEIDON cell. As shown in the video, the inputs folder in POSEIDON already contains some csv files. Here we are going to open inputs/indonesia/small_712_map.csv. This is centered around WPP712 (north of the island of Java) in Indonesia. The model will then look and run very much like all the other abstract runs (including its own fishing front) but within the map currently generated. 5.2 Download other maps There are of course many ways to find maps from GIS sources such as here. Most of these data sets are tif rasters that need to be converted (and sometimes they need to be reprojected as well). The quickest way to get a map into POSEIDON is probably by querying bathymetry from OCTOPUS, a great tool from Marc Weiland when he was at Oxford’s zoology department. Imagine wanting depth data in lat-long coordinates for the area between the points (105,-15) and (139,5). Simply copy paste the following address to your browser (or wget): https://octopus.zoo.ox.ac.uk/geoserver/wcs?service=WCS&amp;version=1.0.0 &amp;request=GetCoverage &amp;format=geotiff &amp;coverage=context:depth_none_009_gebco &amp;bbox=105,-15,139,5 &amp;crs=EPSG:4326 &amp;resx=0.09 Pay particular attention to bbox which is where coordinates are set. This will download a geotiff file with the correct lat-long projection(EPSG:4326). We can turn it into csv in R easily, with something like this: library(raster) library(tidyverse) # read the file depth_raster &lt;- raster(&quot;../tiff_name.tif&quot;) # turn it into csv depth&lt;- as.data.frame(rasterToPoints(depth_raster)) %&gt;% # the depth column is by default the name of the file rename(depth=tiff_name) %&gt;% ## notice that depth is -99999 for land in OCTOPUS, we need to change that to a positive number mutate(depth=ifelse(depth==-99999,10000,depth)) write_csv(depth,&quot;../csv_name.csv&quot;) Ready to go! "],
["different-behaviours.html", "Chapter 6 Different behaviours 6.1 Strategies 6.2 Change Destination Strategy 6.3 Gravitational Search Algorithm 6.4 Heatmap algorithm", " Chapter 6 Different behaviours 6.1 Strategies The whole point of POSEIDON is to be flexible, both in terms of environment and policies but also in terms of fishers’ behaviour. Agents behaviour is defined by their Strategies of which the most important are the following three: Destination Strategy: how do agents choose where to go fish Departing Strategy: how do agents choose when to start a new trip Fishing Strategy: how do agents choose when it is time to stop fishing These are usually complex parameters, some depending on equally complex sub-parameters but in a way it has to be so if we want to capture complicated decision processes. 6.2 Change Destination Strategy Destination strategies represent the way agents choose where to fish. There are very many of them and there is a paper that describes and test their effectivness. You can read a pre-print version here. The default destination strategy is the explore-exploit-imitate agent. It is simple, in the sense that it involves a fixed exploration rate coupled with imitating better competitors when connected through a social network (see paper). It has however a lot of parameters governing a few of its details: These includes: Always Copy Best: when imitating, should I copy the best friend I have or any friend who is doing better? Automatically Ignore Areas where Fish Never Grows: agents never explore areas where fish can’t grow Automatically Ignore MPAs: agents never bother trying to catch in protected areas Backtracks on Bad Exploration: when an exploration make less utility, should my best spot be the place I’ve been before exploring? Drop in Utility Needed For Unfriend: if positive, what percentage of utility difference between what my friend experienced and what I experienced after copying before assuming they are an unreliable friend? Ignore Edge Direction: do I consider friends everyone who is connected to me or only direct connections in the social network? Ignore Failed Trips: If trips fail (because of weather, end of season and so on) should I consider them to judge whether the exploration was successful or not? Max Initial Distance: if positive, the very first spot fished will not be further than this from the fisher’s port Objective Function: the function I use to judge the quality of a trip Probability: what is the probability that next trip will be an exploration or, if not exploring, an imitation. Adaptive means that this probability will change over time as exploration is more or less succesful Step Size: in cells, what is the neighborhood around my current location where I will explore, if needed So that’s quite a lot of switches, although most likely all you really care about is Probability and Step Size. 6.3 Gravitational Search Algorithm Now let’s change the behaviour of the agents to a different algorithm: GSA (you can read more in the paper above). This is much simpler as it involves everyone sharing information with everyone else at all times. The idea is that imitation works as if fishers were planets pulling each other. Their gravitational mass is a monotonic function of profits made. If we run the model with this behaviour algorithm you will see something like this occurring: This is what I call, very scientifically, the conga line. It is a consequence of too much information sharing. It’s quite poor in terms of profits but it works really well when the fish is a big school moving about. 6.4 Heatmap algorithm Another set of algorithms involve the agent building inferential maps of where they think they most amount of profits are. You can select them easily as Heatmap Based as the Destination Strategy: It is quite computationally intensive so it’s usually a good idea to set the parameter Proportion Searched in the Acquisition Function to 0.1; this is the % of cells sampled from the inferential map to choose where to go next. When run it will generate fishing fronts much like explore-exploit-imitate: If you select (double click) a fisher and look at their destination strategy in the inspector tab, you will see the button “Show Heatmap”, you can click it to get an idea of what that particular fisher is thinking: The blue areas are considered “high profits”, white areas are mediocre and red areas are low profits. This map updates as the model runs, but will do so slowly unless Empty List is called first to keep the model from processing too much information. "],
["yaml-scearios-and-batch-runs.html", "Chapter 7 YAML Scearios and Batch Runs 7.1 YAML 7.2 Batch Runs 7.3 Sample Batch Run", " Chapter 7 YAML Scearios and Batch Runs 7.1 YAML So far we’ve been modifying parameters and scenarios by using the GUI. These scenarios can be saved, modified and loaded as text files too. They follow the YAML format. For example, in the POSEIDON parameter section we can press Save Scenario to File to save our parameters into a single, yaml file. You can open it and edit it as a text file (any editor will do except Windows’ notepad; try wordpad or notepad++). It will look something like this: Abstract: biologyInitializer: Diffusing Logistic: carryingCapacity: &#39;5000.0&#39; differentialPercentageToMove: &#39;0.001&#39; grower: Independent Logistic Grower: steepness: uniform 0.6 0.8 maxInitialCapacity: &#39;1.0&#39; minInitialCapacity: &#39;0.0&#39; percentageLimitOnDailyMovement: &#39;0.01&#39; speciesName: Species 0 cheaters: false departingStrategy: Fixed Rest: hoursBetweenEachDeparture: &#39;12.0&#39; destinationStrategy: Imitator-Explorator: alwaysCopyBest: true automaticallyIgnoreAreasWhereFishNeverGrows: false automaticallyIgnoreMPAs: false backtracksOnBadExploration: true dropInUtilityNeededForUnfriend: &#39;-1.0&#39; ignoreEdgeDirection: true ignoreFailedTrips: false maxInitialDistance: -1.0 objectiveFunction: Hourly Profit Objective: opportunityCosts: true probability: Adaptive Probability: explorationProbability: &#39;0.2&#39; explorationProbabilityMinimum: &#39;0.01&#39; imitationProbability: &#39;1.0&#39; incrementMultiplier: &#39;0.02&#39; stepSize: uniform 1.0 10.0 discardingStrategy: No Discarding enginePower: normal 5000.0 100.0 fishers: 100 fishingStrategy: Until Full With Day Limit: daysAtSea: &#39;5.0&#39; fuelTankSize: &#39;100000.0&#39; gasPricePerLiter: &#39;0.01&#39; gear: Random Catchability: gasPerHourFished: &#39;5.0&#39; meanCatchabilityFirstSpecies: &#39;0.01&#39; meanCatchabilityOtherSpecies: &#39;0.01&#39; standardDeviationCatchabilityFirstSpecies: &#39;0.0&#39; standardDeviationCatchabilityOtherSpecies: &#39;0.0&#39; gearStrategy: Never Change Gear habitatInitializer: All Sand holdSize: &#39;100.0&#39; literPerKilometer: &#39;10.0&#39; logbook: No Logbook mapInitializer: Simple Map: cellSizeInKilometers: &#39;10.0&#39; coastalRoughness: &#39;4.0&#39; depthSmoothing: &#39;1000000.0&#39; height: &#39;50.0&#39; maxLandWidth: &#39;10.0&#39; width: &#39;50.0&#39; mapMakerDedicatedRandomSeed: null market: Fixed Price Market: marketPrice: &#39;10.0&#39; networkBuilder: Equal Out Degree: allowMutualFriendships: true degree: &#39;2.0&#39; equalOutDegree: true plugins: [ ] portPositionX: -1 portPositionY: -1 ports: 1 regulation: MPA Only: startingMPAs: [ ] speedInKmh: &#39;5.0&#39; startingMPAs: [ ] usePredictors: false weatherInitializer: Constant Weather: temperature: &#39;30.0&#39; windOrientation: &#39;0.0&#39; windSpeed: &#39;0.0&#39; weatherStrategy: Ignore Weather This is just the list of all parameters from the gui into a text file. There are a few uses for this: Save parameters for iterative modifications or replications Make batch runs Machine readable input to interoperate with other software (probably an optimizer) Modify parameters for which the GUI is not ready yet (sorry!~). These are things like list of strategies and ports. We will see this more in the Peter Snapper example. 7.2 Batch Runs POSEIDON, as all other agent-based models, contains many stochastic parts. In order to draw conclusions from POSEIDON outputs, the same scenario must be run many times – each run will provide slightly different outcomes. By looking at the distribution of outcomes, you can get a sense of the uncertainty around a result. POSEIDON has a batch runner you can use to automate this process. In essence it reads a YAML file, and runs it many times. You can call it by running from terminal (in the POSEIDON directory): ./gradlew batch Or on windows: gradlew.bat batch It is a quite simple graphical interface: Its parameters are: Columns To Print: a list, subdivided by “,” of all the yearly data sets we want to collect for each simulation. Unfortunately it is case-sensitive and so quite annoying to use. The kind of data collectable depends on each scenario but they the buttons that appear in Yearly Data Set in the Aggregate Data tab of a normal POSEIDON RUN: Heatmap Gatherer Start Year: when this is positive it will collect a heatmap of all the fisher effort from that year till the end of the simulation Number of Runs: How many times to run the scenario Output Folder: which directory will store all the results of the batch run Policy File: an additional input scenario to simulate policy shocks Random Seed: the random seed defining the first simulation. Copying a previous random seed should generate an exact replica of the simulation including all the stochastic components. Yaml File: the path of the scenario YAML file to run Years to Run: how many years should each scenario simulate? 7.3 Sample Batch Run Open the batch runner. Set the runs and years to run to 5 and add “Species 0 Landings” to the list of columns to print. Open the YAML file describing the scenario you want to imitate. Here I am using baseline.yaml which is just a file I created by pressing Save Scenario to File from POSEIDON’s scenario selector without modifying any parameter. After pressing Start you will see a very basic progress bar showing how many simulations have completed. Once completed you can look in the Output Folder and see a bunch of files: Each directory contains all the data produced by each simulation, the run$.csv file contain a table of all the selected data columns to print: ## # A tibble: 5 x 3 ## `Total Effort` `Average Cash-Flow` `Species 0 Landings` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 356233. 71605. 737979. ## 2 218308. 59469. 624133. ## 3 173664. 53773. 569650. ## 4 152381. 51758. 550701. ## 5 165219. 49201. 524677. Probably the most important file is the _batch.csv file which contains all the selected columns for all runs in a tidy format: ## # A tibble: 75 x 4 ## run year variable value ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 0 0 Total Effort 356233. ## 2 0 1 Total Effort 218308. ## 3 0 2 Total Effort 173664. ## 4 0 3 Total Effort 152381. ## 5 0 4 Total Effort 165219. ## 6 0 0 Average Cash-Flow 71605. ## 7 0 1 Average Cash-Flow 59469. ## 8 0 2 Average Cash-Flow 53773. ## 9 0 3 Average Cash-Flow 51758. ## 10 0 4 Average Cash-Flow 49201. ## # ... with 65 more rows This makes it easy to plot in R: "],
["policies.html", "Chapter 8 Policies 8.1 Policy in POSEIDON 8.2 Example Setup 8.3 No Regulations 8.4 Total Allowable Quota 8.5 Individual Tradeable Quotas 8.6 Fines", " Chapter 8 Policies 8.1 Policy in POSEIDON At its simplest policies are just another scenario parameter. In the default Abstract scenario the parameter of interest is Regulation. There are (unfortunately) quite a lot of options. Most policies are static but a few are dynamic. Here we show by example only a few static ones. 8.2 Example Setup To show the various effects of policies we want to modify slightly the biology and geography of the abstract scenario. In particular: We want to change the biology initializer to “Split in Half” This simply means that now there will be two species of fish, Species 0(red) and Species 1(blue), red fish living in the north part of the map, blue fish lives in the south We want to set Coastal Roughness in the Map Initializer to 0 This flattens the coast so that it looks like a straight line. Useful when making comparisons We want to set Port Position X to 40 and Port Position Y to 25 This will set the port right there in the middle of the map. Again, useful to compare the effect of different regulations Save this scenario as split.yaml in some folder. This way we can re-use it when we change policies. Here’s a video showing how to do this: Here’s a video showing the final product 8.3 No Regulations If we don’t change the Regulation parameters, the fishery is unregulated. The result is once again the fishing front, agents start fishing near port and then spread out. Both red and blue fish are caught in approximately equal amounts. 8.4 Total Allowable Quota Imagine that we want to target about 500,000 units of red fish caught per year but at the same time protect the blue fish by only catching 100,000 units. The simplest possible way to do so is to add a TAC to the fishery stipulating that whenever either limit is reached the fishery closes for the remainder of the year. This is relatively simple to do in POSEIDON: Load the split.yaml scenario you prepared in the previous section (click on Open Scenario from File button at the bottom of the scenario selector) Set Regulation to Multi-TAC, set First Species Quota to 500,000 and Other Species Quota to 100,000 If we run the model now we will see a few things happen. First, the fishery will proceed in “pulses”. Agents will fish until one of the two quota limits is triggered at which point the season closes and all the fishers come to port till the end of year. Second, within each pulse the fishery still evolve along a front, eating up both red and blue fish. Third, because blue quotas are much lower, only about 100,000 units of red are caught each year: a quite serious waste of quotas. The problem is quite obvious: there is no particular incentive for any fisher to target red fish in particular. Agents will just fish whatever is more profitable which tends to be what’s closer. 8.5 Individual Tradeable Quotas The American solution to this problem tends to be to make quotas tradeable. The idea is that if quotas for the rare fish is expensive, agents will try and avoid it as much as possible. We can replicate this in POSEIDON: Change Regulation to Multi-ITQ and set the Quota First Species to 5000 and the Quota Other Species to 1000. The ITQ regulation numbers refer to the individual quota allotment given. Since by default there are 100 fishers, the total amount of quotas is the same as the TAC example above Tick the Use Predictors parameter to true As explained in the paper, an ITQ system can only work when agents form an expectations of what the value of their quota is. This is not difficult to do but the formulas are turned off by default because they are a computationally expensive. If Use Predictors is not turned on, no agents will participate in the quota market The emergent response of the system is more or less what we expect. Fishers, especially after a first year where prices are unsettled, learn to avoid the blue areas and focus on the red ones. Notice that strictly speaking the agents do not know where fish live, this is all driven by random exploration and imitation. 8.6 Fines A similar result can be achieved simply by imposing a fine on catching blue fish. To do so in POSEIDON: Change the Market parameter to Fixed Price Market Array and change its Prices to: “+10,-10” Basically Fixed Price Market Array will set the price for each species (per unit caught). “+10” will be the price of red fish, “-10” will be the price of blue fish. This generates much the same blue avoidance, without the need of a complicated quota market: Notice however that the kind of control is slightly different. With an ITQ you know for sure that never gets caught past their quota regardless of the conditions on the ground. With a simple fine you don’t really know until you simulate it how effective it is and how much ends up being caught. This is of course the informational problem of all Pigouvian taxes. "],
["changing-policies-within-the-simulation.html", "Chapter 9 Changing policies within the simulation 9.1 Dynamic changes 9.2 Switch to quotas 2 years in the simulation 9.3 Closed Season 9.4 Draw MPAs on the fly", " Chapter 9 Changing policies within the simulation 9.1 Dynamic changes Policies can be modified while the simulation is running. The idea of POSEIDON is that the agents ought to be able to adapt to whatever you throw at them without having to stop and recode them. Hopefully this section will give you some confidence that this is indeed the case. 9.2 Switch to quotas 2 years in the simulation Start POSEIDON and the abstract scenario without making any modifications to the parameters. After pressing , the tab called Policies will become available in the top of the controller. We can use it for, among other things, change the regulations of the fishery. Run the model for 2 years, then: Click on the Policies tab Choose Mono-IQ for the Global Regulations parameter This regulation means that fishers will be given individual non-tradeable quota (mono refers to these quotas being only valid for the first species). Change Individual Quota to 500 or 600 This is the maximum yearly amount of fish catchable by each boat Press the button Change regulations for all agents You will see the fishery starting to pulse as quotas ends and replenish as well as a progressive retreat of the fishing front as biomass grows back in previously depleted areas. You can also look at data such as Species 0 Landings, both yearly and daily, to see the aggregate effects of this policy change. 9.3 Closed Season Let’s switch from a quota system back to a maximum number of days at sea system: Click on the Policies tab Choose Fishing Season for the Global Regulations parameter Change Season Length to 200 This implies that only 200 days out are allowed for each boat each year Press the button Change regulations for all agents The fishery will still pulse, but this time at regular time intervals. Again, you can look at the data to get a better idea of what this means in aggregate. 9.4 Draw MPAs on the fly Let’s remove effort constraints but add some MPAs in the area. Click on the Policies tab Choose Fishing Season for the Global Regulations parameter but set season length to 400 Any number above 365 really means that there is no season Press the button Change regulations for all agents Press the button Draw new MPAs Now if you click and hold on the map you can draw MPAs This will look like grey boxes in the model You can do this repeatedly until you click again on the Draw new MPAs button The fishery will not pulse but the agents will scrupulously avoid protected areas. "],
["applying-poseidon.html", "Chapter 10 Applying POSEIDON 10.1 Flexible Scenario 10.2 How to use data in POSEIDON 10.3 The Peter Snapper Fishery 10.4 Adding boats to the right ports 10.5 Adding knowledge about boat operations 10.6 The simplest possible biology input 10.7 Calibrating Catchability 10.8 Validating", " Chapter 10 Applying POSEIDON 10.1 Flexible Scenario In this section we go through a proper attempt at using POSEIDON straight from translating data and knowledge about the fishery to calibration and validation. It is still all fake data, of course, but I hope it is useful as an exercise. In this section we will focus on the Flexible scenario. It is very similar to the Abstract scenario we have dealt with in the previous chapters but it has a few modifications to make it easy to add multiple populations, regulations and ports. The downside of it is that these modifications are still unsupported by the GUI, so most of the edits will have to be done on the YAML file themselves. You can run the Flexible scenario just by selecting it in the scenario screen. When started it looks and feels much like the Abstract example except for having two ports on by default. It pays to take a look at the YAML file of the scenario since we are supposed to work primarily on this: Flexible: allowFriendshipsAcrossPorts: false biologyInitializer: Diffusing Logistic: carryingCapacity: &#39;5000.0&#39; differentialPercentageToMove: &#39;0.001&#39; grower: Independent Logistic Grower: steepness: uniform 0.6 0.8 maxInitialCapacity: &#39;1.0&#39; minInitialCapacity: &#39;0.0&#39; percentageLimitOnDailyMovement: &#39;0.01&#39; speciesName: Species 0 cheaters: false fisherDefinitions: - departingStrategy: Fixed Rest: hoursBetweenEachDeparture: &#39;12.0&#39; destinationStrategy: Imitator-Explorator: alwaysCopyBest: true automaticallyIgnoreAreasWhereFishNeverGrows: false automaticallyIgnoreMPAs: false backtracksOnBadExploration: true dropInUtilityNeededForUnfriend: &#39;-1.0&#39; ignoreEdgeDirection: true ignoreFailedTrips: false maxInitialDistance: -1.0 objectiveFunction: Hourly Profit Objective: opportunityCosts: true probability: Adaptive Probability: explorationProbability: &#39;0.2&#39; explorationProbabilityMinimum: &#39;0.01&#39; imitationProbability: &#39;1.0&#39; incrementMultiplier: &#39;0.02&#39; stepSize: uniform 1.0 10.0 discardingStrategy: No Discarding fishingStrategy: Until Full With Day Limit: daysAtSea: &#39;5.0&#39; fuelTankSize: &#39;100000.0&#39; gear: Random Catchability: gasPerHourFished: &#39;5.0&#39; meanCatchabilityFirstSpecies: &#39;0.01&#39; meanCatchabilityOtherSpecies: &#39;0.01&#39; standardDeviationCatchabilityFirstSpecies: &#39;0.0&#39; standardDeviationCatchabilityOtherSpecies: &#39;0.0&#39; gearStrategy: Never Change Gear holdSize: &#39;100.0&#39; hourlyVariableCost: &#39;0.0&#39; initialFishersPerPort: Port 0: 50 Port 1: 50 literPerKilometer: &#39;10.0&#39; logbook: No Logbook regulation: Anarchy speedInKmh: &#39;5.0&#39; tags: &#39;&#39; usePredictors: false weatherStrategy: Ignore Weather gasPricePerLiter: &#39;0.01&#39; habitatInitializer: All Sand mapInitializer: Simple Map: cellSizeInKilometers: &#39;10.0&#39; coastalRoughness: &#39;4.0&#39; depthSmoothing: &#39;1000000.0&#39; height: &#39;50.0&#39; maxLandWidth: &#39;10.0&#39; width: &#39;50.0&#39; mapMakerDedicatedRandomSeed: null market: Fixed Price Market: marketPrice: &#39;10.0&#39; networkBuilder: Equal Out Degree: allowMutualFriendships: true degree: &#39;2.0&#39; equalOutDegree: true plugins: [ ] portInitializer: Random Ports: numberOfPorts: &#39;2.0&#39; portSwitching: false weatherInitializer: Constant Weather: temperature: &#39;30.0&#39; windOrientation: &#39;0.0&#39; windSpeed: &#39;0.0&#39; The main difference from the Abstract scenario is the presence of fisherDefinitions which is just a list (in yaml you can tell it’s a list because each item starts with -) of populations. A population is described by the usual behavioural rules (strategies) as well as their number by port listed in initialFishersPerPort. 10.2 How to use data in POSEIDON As with all models, there are 3 basic uses for data in POSEIDON. It can be used either as: Input: basically by using what we know to set some parameters directly (number of boats, geography, port locations and the like) Calibration: we use the data to select some parameters indirectly. For example we know how much was landed for the past 5 years and we want to find the catchability parameter that generate the same time series. Validation: we don’t use the data to set any parameters, we only use it after everything else is set to make sure the model makes sense (basically “out-of-sample” prediction error from statistics) Sometimes the way to use a particular datum is clear, other times it is up to the modeller to figure it out. It should be said that often we just don’t have enough data. There are three basic approaches on how to setup the model when data doesn’t exist: Guess: use expert knowledge or some basic theoretical result to model certain parameters. This is of course a much weaker parametrization than using real data but it is sometimes necessary Sensitivity Analysis: run the model multiple times for a large enough confidence interval around the parameters you do not know much about. This tends to be hard to do when there are a lot of uknowns unless you use a smart search strategy Worst Case Scenario: like sensitivity analysis but looking specifically for the worst possible combination of parameters. This is useful when we need to provide policy suggestions. It’s at least a way to know whether we can be sure not to make things worse off by intervening. POSEIDON of course has a lot of variables (say, boat speed or fuel consumption) and one might wonder why using it in data poor scenarios where a bio-economic model would only require at most a guess on global fishing mortality. Three reasons. First, it is often the case that we do have some knowledge about some details of the fishery which we wouldn’t be able to use when aggregating everything back to global fishing mortality (perhaps the overall number of boats, the price premium for plate-size fish or which port catches most of what). Second, we might care deeply about the distribution of benefits and costs both in terms of human populations as well as geographical effects on the biology which call for a model that at least tracks these details. Third, a global fishing mortality guess papers over all the actual things we need to make a guess about. POSEIDON, when presented with absolute lack of any knowledge, forces you to be explicit about everything you do not know. At its simplest POSEIDON need to have some knowledge about the following: Market The ex-vessel price of fish caught Geography: A decent enough bathymetry to distribute the fish in Management: The policies in place (and if calibrating then also the changes in policies over time) Fishing Fleet: 10.2 of vessels, vessel capacity and speed Gear type/catchability (usually by calibration) Operational costs (fuel, logistics) Maximum possible effort (max number of days out, max length of a trip) Biology: For each species at least Some form of carrying capacity Current biomass Some depth ranges where these fish live 10.3 The Peter Snapper Fishery Let’s assume we want to study a basic made-up fishery: the Indonesian Petern Snapper fishery. I would classify this as a medium-data fishery, since we have a decent knowledge of its human side while knowing basically nothing biologically (after all, 80% of the catch comes from unassessed fisheries according to ???). Let’s start with some very basic knowledge: The fishery is located around Bali, say between lat-long \\((114.5,-6.9)\\) and (127.6, -12.85) It’s a single species fishery We know too little about age structure so this will be a biomass-only model We can already add some of this knowledge in. First, we want to add the right map. We have seen how to download maps in section 5; fortunately this particular map comes with POSEIDON in directory: inputs/indonesia/indonesia_latlong.csv. Let’s modify the mapInitializer: mapInitializer: From File Map: gridWidthInCell: &#39;70.0&#39; header: true latLong: true mapFile: /home/carrknight/code/POSEIDON/inputs/indonesia/indonesia_latlong.csv The number of cells is set to 70 since that generates cells approximately 30km wide. This is useful as it allows us to ignore things like congestion or boats moving between cells as they fish. We can also use a more detailed biology parameter; we still don’t know its parameters but we can prepare for them: biologyInitializer: Single Species Biomass Normalized: biomassSuppliedPerCell: false carryingCapacity: &#39;500000000&#39; differentialPercentageToMove: &#39;0.001&#39; grower: Common Logistic Grower: steepness: &#39;0.5&#39; initialBiomassAllocator: Random Allocator: maximum: &#39;1&#39; minimum: &#39;0&#39; initialCapacityAllocator: Equal Allocation: constantValue: &#39;1.0&#39; percentageLimitOnDailyMovement: &#39;0.01&#39; speciesName: Peter Snapper unfishable: false This biology initializer looks complicated but it just involves a few things: carryingCapacity controls the \\(K\\) of the overall fishery. Common Logistic Grower means that recruitment is global (a single logistic growth for all the cells). steepness is the malthusian growth of the fish initialBiomassAllocator defines the current biomass ratio \\(\\frac{\\text{Biomass Now}}{K}\\) initialCapacityAllocator defines which areas of the ocean are habitable by this species differentialPercentageToMove and percentageLimitOnDailyMovement define the speed of fish movement. These numbers imply a very slow moving fish So far we don’t know enough to fill any of them. Finally, since we don’t have the resources to field a serious behavioural survey, let’s stick with agents acting as simple explore-exploit-imitate agents with a flat 20% chance of exploration. It proved quite effective in our West Coast application. destinationStrategy: Imitator-Explorator: alwaysCopyBest: true automaticallyIgnoreAreasWhereFishNeverGrows: true automaticallyIgnoreMPAs: false backtracksOnBadExploration: true dropInUtilityNeededForUnfriend: &#39;-1.0&#39; ignoreEdgeDirection: true ignoreFailedTrips: false maxInitialDistance: -1.0 objectiveFunction: Hourly Profit Objective: opportunityCosts: true probability: Fixed Probability: explorationProbability: &#39;0.2&#39; imitationProbability: &#39;1.0&#39; stepSize: uniform 1.0 10.0 Notice that we set automaticallyIgnoreAreasWhereFishNeverGrows to true. This has no effect now, but what it does is that it prevents fishers from wasting time exploring areas where the depth or habitat makes it impossible for Peter Snapper to live. Once all those modifications are done, the model looks like this: This is yaml file now: Flexible: allowFriendshipsAcrossPorts: false biologyInitializer: Single Species Biomass Normalized: biomassSuppliedPerCell: false carryingCapacity: &#39;500000000&#39; differentialPercentageToMove: &#39;0.001&#39; grower: Common Logistic Grower: steepness: &#39;0.5&#39; initialBiomassAllocator: Random Allocator: maximum: &#39;1&#39; minimum: &#39;0&#39; initialCapacityAllocator: Equal Allocation: constantValue: &#39;1.0&#39; percentageLimitOnDailyMovement: &#39;0.01&#39; speciesName: Peter Snapper unfishable: false cheaters: false fisherDefinitions: - departingStrategy: Fixed Rest: hoursBetweenEachDeparture: &#39;12.0&#39; destinationStrategy: Imitator-Explorator: alwaysCopyBest: true automaticallyIgnoreAreasWhereFishNeverGrows: true automaticallyIgnoreMPAs: false backtracksOnBadExploration: true dropInUtilityNeededForUnfriend: &#39;-1.0&#39; ignoreEdgeDirection: true ignoreFailedTrips: false maxInitialDistance: -1.0 objectiveFunction: Hourly Profit Objective: opportunityCosts: true probability: Fixed Probability: explorationProbability: &#39;0.2&#39; imitationProbability: &#39;1.0&#39; stepSize: uniform 1.0 10.0 discardingStrategy: No Discarding fishingStrategy: Until Full With Day Limit: daysAtSea: &#39;5.0&#39; fuelTankSize: &#39;100000.0&#39; gear: Random Catchability: gasPerHourFished: &#39;5.0&#39; meanCatchabilityFirstSpecies: &#39;0.01&#39; meanCatchabilityOtherSpecies: &#39;0.01&#39; standardDeviationCatchabilityFirstSpecies: &#39;0.0&#39; standardDeviationCatchabilityOtherSpecies: &#39;0.0&#39; gearStrategy: Never Change Gear holdSize: &#39;100.0&#39; hourlyVariableCost: &#39;0.0&#39; initialFishersPerPort: Port 0: 50 Port 1: 50 literPerKilometer: &#39;10.0&#39; logbook: No Logbook regulation: Anarchy speedInKmh: &#39;5.0&#39; tags: &#39;&#39; usePredictors: false weatherStrategy: Ignore Weather gasPricePerLiter: &#39;0.01&#39; habitatInitializer: All Sand mapInitializer: From File Map: gridWidthInCell: &#39;70.0&#39; header: true latLong: true mapFile: /home/carrknight/code/oxfish/inputs/indonesia/indonesia_latlong.csv mapMakerDedicatedRandomSeed: null market: Fixed Price Market: marketPrice: &#39;10.0&#39; networkBuilder: Equal Out Degree: allowMutualFriendships: true degree: &#39;2.0&#39; equalOutDegree: true plugins: [ ] portInitializer: Random Ports: numberOfPorts: &#39;2.0&#39; portSwitching: false weatherInitializer: Constant Weather: temperature: &#39;30.0&#39; windOrientation: &#39;0.0&#39; windSpeed: &#39;0.0&#39; 10.4 Adding boats to the right ports The fleet is the major component of POSEIDON and the one that require the most knowledge. There are a several ways to learn about it: Surveys: interviewing fishers (or, more likely, interviewing people who interview fishers) Logbook data: if reliable, logbook data contains basically all the possible human data observable VMS / Satellite: an alternative when logbook data is unreliable or not available Formulas: there are quite a lot of handrules about how much a boat is expected to catch given its size or consume in gas according to their engine power, these could be used in the model. There are some basic facts about snapper fisheries in Indonesia we can use immediately: Snapper sells on average for about 40,000 IDR per kg Diesel costs about 10,000 IDR per liter Let’s also assume the Peter Snapper fishery is a licensed fishery and that: 25 boats fish from Benoa 50 boats fish from Kupang Let’s add this to the model. First, let’s just agree to use IDR as currency. We want to add prices and gas costs: gasPricePerLiter: &#39;10000&#39; market: Fixed Price Market: marketPrice: &#39;40000.0&#39; Let’s define the ports now, in lat-long coordinates. You can grab them from google maps (an advantage in using lat-long coordinates). POSEIDON tries to place the port correctly if the coordinates are slightly too far inland or at sea, so there is no reason to worry about too much precision. POSEIDON however will throw an error if two ports share the same cell. In that case, merge the ports or increase the map resolution. portInitializer: List of Ports: ports: Benoa: 115.238843,-8.799605 Kupang: 123.586249,-10.148044 usingGridCoordinates: false Notice usingGridCoordinates is set to false. When that is set to true you are to provide the coordinates in terms of POSEIDON grid instead of lat-long. Finally, let’s place fishers in the right port: initialFishersPerPort: Benoa : 25 Kupang: 50 We can run the model now; it’s still very incomplete but at least there are the right number of boats and ports. This the YAML file so far: Flexible: biologyInitializer: Single Species Biomass Normalized: biomassSuppliedPerCell: false carryingCapacity: &#39;500000000&#39; differentialPercentageToMove: &#39;0.001&#39; grower: Common Logistic Grower: steepness: &#39;0.5&#39; initialBiomassAllocator: Random Allocator: maximum: &#39;1&#39; minimum: &#39;0&#39; initialCapacityAllocator: Equal Allocation: constantValue: &#39;1.0&#39; percentageLimitOnDailyMovement: &#39;0.01&#39; speciesName: Peter Snapper unfishable: false cheaters: false fisherDefinitions: - departingStrategy: Fixed Rest: hoursBetweenEachDeparture: &#39;12.0&#39; destinationStrategy: Imitator-Explorator: alwaysCopyBest: true automaticallyIgnoreAreasWhereFishNeverGrows: true automaticallyIgnoreMPAs: false backtracksOnBadExploration: true dropInUtilityNeededForUnfriend: &#39;-1.0&#39; ignoreEdgeDirection: true ignoreFailedTrips: false maxInitialDistance: -1.0 objectiveFunction: Hourly Profit Objective: opportunityCosts: true probability: Fixed Probability: explorationProbability: &#39;0.2&#39; imitationProbability: &#39;1.0&#39; stepSize: uniform 1.0 10.0 discardingStrategy: No Discarding fishingStrategy: Until Full With Day Limit: daysAtSea: &#39;5.0&#39; fuelTankSize: &#39;100000.0&#39; gear: Random Catchability: gasPerHourFished: &#39;5.0&#39; meanCatchabilityFirstSpecies: &#39;0.01&#39; meanCatchabilityOtherSpecies: &#39;0.01&#39; standardDeviationCatchabilityFirstSpecies: &#39;0.0&#39; standardDeviationCatchabilityOtherSpecies: &#39;0.0&#39; gearStrategy: Never Change Gear holdSize: &#39;100.0&#39; hourlyVariableCost: &#39;0.0&#39; initialFishersPerPort: Benoa : 25 Kupang: 50 literPerKilometer: &#39;10.0&#39; logbook: No Logbook regulation: Anarchy speedInKmh: &#39;5.0&#39; tags: &#39;&#39; usePredictors: false weatherStrategy: Ignore Weather gasPricePerLiter: &#39;10000&#39; habitatInitializer: All Sand mapInitializer: From File Map: gridWidthInCell: &#39;70.0&#39; header: true latLong: true mapFile: /home/carrknight/code/oxfish/inputs/indonesia/indonesia_latlong.csv mapMakerDedicatedRandomSeed: null market: Fixed Price Market: marketPrice: &#39;40000.0&#39; networkBuilder: Equal Out Degree: allowMutualFriendships: true degree: &#39;2.0&#39; equalOutDegree: true plugins: [ ] portInitializer: List of Ports: ports: Benoa: 115.238843,-8.799605 Kupang: 123.586249,-10.148044 usingGridCoordinates: false portSwitching: false weatherInitializer: Constant Weather: temperature: &#39;30.0&#39; windOrientation: &#39;0.0&#39; windSpeed: &#39;0.0&#39; 10.5 Adding knowledge about boat operations Imagine that we get hold of an expert and get some basic answers on how boats in the fishery work. In particular: Boats can hold at most 15t of fish before being too full to continue Trips never last more than 10 days (when families back to port start getting angry or the boat runs out of cigarettes) Boats cruise at about 8.5 knots (about 16kph) Fishing is done by droplining Let’s also assume we manage to back out (by formula, by asking the expert or by sheer guess) some logistics about the fishery: Boats consume about 3\\(\\frac {l}{\\text{km})\\) of diesel when cruising Each hour spent fishing consumes 70l of diesel (keeping boat steady and so on) We can add all these informations in. Start with the boat information in the fisherDefinitions fishingStrategy: Until Full With Day Limit: daysAtSea: &#39;10.0&#39; gear: Random Catchability: gasPerHourFished: &#39;70.0&#39; holdSize: &#39;15000.0&#39; literPerKilometer: &#39;3.0&#39; speedInKmh: &#39;16.0&#39; We can run the model again. We have pretty realistic boats now but unfortunately we still have no idea about what the biology looks like. 10.6 The simplest possible biology input Trevor A. Branch lists 15 “fisheries controversies” on his website. Number 2 is Can we use catch data alone to make inferences about fishery stock status?. This is in contrast to the standard way of assessing stocks which requiers the time series of both landings and effort, as in chapter 11 of (???). The classic technique for those brave enough, like us for the Peter Snapper fishery, to do stock assessment with landings alone is by using the catch-MSY method (???). The basic idea is that if you have some landings and some prior on what the stock looks like now, there are only a few combinations of \\(K\\) (carrying capacity) and \\(r\\) (malthusian growth) that qualify. Let’s try our best with what we have (がんばれ). Imagine having decent landing data (in kg) for the past 10 years. ## # A tibble: 10 x 1 ## Landings ## &lt;dbl&gt; ## 1 30765238. ## 2 23983452. ## 3 19843028. ## 4 16148729. ## 5 13046744. ## 6 10867591. ## 7 9221522. ## 8 7628867. ## 9 7041957. ## 10 6200139. Looks like a nasty drop from a 30,000t fishery to a 6,200t fishery in the span of 10 years. We can go lookup on FishBase the properties of the Peter Snapper (except of course that it’s an imaginary fish). Let’s just pretend it claims the Peter Snapper to be of Low resilience (like, say, the flame snapper). This is useful because it means we can probably bound the malthusian growth parameter \\(r \\in (.2,.5)\\) While we are on FishBase we can also take a look at the depth range of the fish. Let’s say it gives us a range between 30 and 800 meters. To use catch-MSY we need some bounds on the current and initial (10 years ago) depletion rate. Let’s say 10 years ago we guess the biomass was at 70-80% of \\(K\\) as the fishery was still young. Given the big drop in landings we assume the biomass remaining somewhere between 5-25% of \\(K\\). These are all the inputs needed for catch-MSY. There are many implementation of the method but I like the original code that came with the paper the most. It looks something like this: and when run it gives us a guessed \\(K\\) and \\(r\\): geom. mean r = 0.372 geom. mean k = 110749315 to be finished 10.7 Calibrating Catchability coming soon! 10.8 Validating coming soon! "],
["references.html", "References", " References "]
]
