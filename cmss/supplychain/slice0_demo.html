<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Supply Chain - Slice 0</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="slice0_demo_files/libs/clipboard/clipboard.min.js"></script>
<script src="slice0_demo_files/libs/quarto-html/quarto.js"></script>
<script src="slice0_demo_files/libs/quarto-html/popper.min.js"></script>
<script src="slice0_demo_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="slice0_demo_files/libs/quarto-html/anchor.min.js"></script>
<link href="slice0_demo_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="slice0_demo_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="slice0_demo_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="slice0_demo_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="slice0_demo_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Supply Chain - Slice 0</h1>
</div>



<div class="quarto-title-meta">

    
    
  </div>
  

</header>

<div class="cell">

</div>
<div class="cell">

</div>
<section id="whats-this" class="level2">
<h2 class="anchored" data-anchor-id="whats-this">What’s this?</h2>
<p>Made a very simple python agent-based model of supply chains. The interesting part of the project is perishables and waste, but here I am starting with a very simple inventory management problem with one item.<br>
I start this small because this kind of setting is well understood and I can make sure the simulation works as intended.</p>
<p>It is still very possible that most of our project will actually <em>not</em> involve supply chains per se, but I think by the next demo we will have something useful enough to tell whether it fits with the overall project or not.</p>
</section>
<section id="simulations" class="level2">
<h2 class="anchored" data-anchor-id="simulations">Simulations</h2>
<p>This model is built in pure python (not using MESA yet). Each “agent” is a firm. This firm manages a single type of good. The firm needs to buy, store and sell this item to other firms or a final consumer.<br>
This is not an economic model: there are no prices, no production and no labour. This is purely a dynamic inventory system: the firm needs to fulfill its orders by minimizing its costs.<br>
Firms pay these costs:</p>
<ol type="1">
<li><em>Holding cost</em>: each unsold item costs <span class="math inline">\(h\$\)</span> a day to store and handle</li>
<li><em>Setup cost</em>: each time a firm buys any item from its supplier, it incurs a cost of <span class="math inline">\(s\$\)</span> to organize the delivery</li>
<li><em>Purchasing cost</em>: each time has a price <span class="math inline">\(u\$\)</span> it needs to pay</li>
</ol>
<p>On the other hand, the firm makes <span class="math inline">\(p\$\)</span> back for every item it sells to its clients.</p>
<p>The objective is to manage one’s inventory so that the costs (of holding and setup) are small but at the same time we manage to fulfill all the orders of our clients.</p>
<section id="one-agent" class="level3">
<h3 class="anchored" data-anchor-id="one-agent">One Agent</h3>
<p>The simplest possible case is</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="./onegood/mermaid1.png" class="img-fluid" width="800"></p>
</div>
</div>
<p>To keep things super-simple:</p>
<ul>
<li>the producer is just an infinite pool of items waiting to be ordered</li>
<li>consumers always order 10 items every day</li>
</ul>
<p>Now let’s say that the firm can order items in the evening from the producer and they arrive in the morning before the consumers show up, then we can simulate the firm’s inventory resupply decisions. Let’s just say the agent tries to keep its inventory at 25 items at all times.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> one_agent_scenario <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> base_policy_oneagent_run(order_policy<span class="op">=</span>BasePolicy(<span class="dv">25</span>),</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                         initial_inventory<span class="op">=</span><span class="dv">25</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>single_firm<span class="op">=</span>pd.DataFrame(result.data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we plot the inventory at the end of the day (before the resupply is delivered) we get a very boring dynamic:</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="slice0_demo_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>At the end of each day, the agent is always left with 15 items, with 10 more ordered and ready to go.</p>
<p>Now, if the agent pays 2$ for each time it organizes an order and 0.01$ for each day it stores each item, over the course of 100 days he is paying 200$ in ordering costs and 15$ of holding costs. It’s not a very good strategy because he’s ordering too often.</p>
<p>A different strategy we could employ is have the agent make bigger orders but only every now and then. If, say, we are going to make an order every time our inventory on hand drops below 20 units, what would be the right order to make?<br>
Well we can run the simulation very many times and figure that one:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> []</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> order_quantity <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>,<span class="dv">101</span>):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    result<span class="op">=</span> base_policy_oneagent_run(</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        order_policy<span class="op">=</span>FixedReorderPointPolicy(</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>            reorder_point<span class="op">=</span><span class="dv">20</span>,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            order_quantity<span class="op">=</span>order_quantity</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        cost_manager<span class="op">=</span>FixedCostsManager(</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>            unit_holding_costs<span class="op">=</span><span class="fl">0.01</span>,</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            order_cost<span class="op">=</span><span class="dv">2</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        ),</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        initial_inventory<span class="op">=</span><span class="dv">20</span>,</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        time_steps<span class="op">=</span> <span class="dv">365</span><span class="op">*</span><span class="dv">10</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    data.append({</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">"order_quantity"</span> : order_quantity,</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">"holding_costs"</span> : <span class="bu">sum</span>(result.data[<span class="st">"HOLDING_COST"</span>]),</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="st">"ordering_costs"</span> : <span class="bu">sum</span>(result.data[<span class="st">"ORDERING_COST"</span>])</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>data<span class="op">=</span>pd.DataFrame(data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 91
Columns: 3
$ order_quantity &lt;dbl&gt; 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,…
$ holding_costs  &lt;dbl&gt; 365.00, 583.82, 620.38, 620.37, 656.88, 729.85, 693.38,…
$ ordering_costs &lt;dbl&gt; 7300, 6638, 6084, 5616, 5216, 4868, 4564, 4296, 4056, 3…</code></pre>
</div>
<div class="cell-output-display">
<p><img src="slice0_demo_files/figure-html/eoqplot-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The larger the order quantities, the lower setup costs (you order less times) but the higher the holding costs (you need to keep a lot of stuff in your store). You minimize costs when ordering 63 units for each order.</p>
<p>There is actually a known formula they use in supply chains for this, the <a href="https://en.wikipedia.org/wiki/Economic_order_quantity">EOQ</a> which says</p>
<p><span class="math display">\[ \text{Order Size} = \sqrt{ \frac{2 \times \text{Demand} \times \text{Ordering Costs}}{\text{Holding Costs}}} \]</span> Which in this example, with these numbers, give you <span class="math inline">\(\approx 63.24\)</span>, which is nicely more or less the answer we got.</p>
<p>So now we know the very basics of the model work. Time to actually add multiple agents!</p>
</section>
<section id="many-agents" class="level3">
<h3 class="anchored" data-anchor-id="many-agents">Many Agents</h3>
<p>Let’s make an actual agent-based model, with multiple agents acting in the supply chain:</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="./onegood/mermaid2.png" class="img-fluid" width="800"></p>
</div>
</div>
<p>There are now:</p>
<ul>
<li>4 retailers who buy straight from the producer and sell to consumers</li>
<li>1 intermediate buyer who buys from the producer but sells to some “small retailers”</li>
<li>2 small retailers who buy from the intermediate firm and sell to consumers</li>
</ul>
<p>It is also a more complicated model in that:</p>
<ul>
<li>Daily demand is random (<span class="math inline">\(\sim U[5,10]\)</span>) and independent for each firm</li>
<li>There are delivery lags:
<ul>
<li>It takes 1 day for producer to deliver to retailers</li>
<li>It takes 1 day for producer to deliver to intermediate seller</li>
<li>It takes 2 more days for intermediate to deliver to small retailers</li>
</ul></li>
</ul>
<p>Knowing that everybody has the same order/holding costs, we would like to figure out how to organize the inventory management so that we <em>maximize profits</em> while having no stockouts.<br>
To do so we need to set 6 parameters</p>
<ul>
<li>Reorder point <span class="math inline">\(s\)</span> (i.e.&nbsp;how low should inventory get before we make a new order) for:
<ol type="1">
<li>Each retailer</li>
<li>Intermediary</li>
<li>Each small retailer</li>
</ol></li>
<li>Order quantity <span class="math inline">\(Q\)</span> (i.e.&nbsp;when we do make an order to our supplier, how many items should we order?), for:
<ol start="4" type="1">
<li>Each retailer</li>
<li>Intermediary</li>
<li>Each small retailer</li>
</ol></li>
</ul>
<p>We have at a minimum 6 parameters to set and this is a quite tricky optimization because the inventory decisions of the intermediary depend very much on the order quantity decisions of the small retailers (i.e.&nbsp;if downstream they make big orders, upstream you need to hold on to large inventories).</p>
<p>It turns out however that even a simple hill-climber can work here:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fixed_reorder_run_ga(<span class="bu">input</span>: np.array) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""this function gets an numpy array as input and pass it as input for a simulation"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    all_profits <span class="op">=</span> []</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> fixed_reorder_run(</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            order_quantity_retailer<span class="op">=</span><span class="bu">round</span>(<span class="bu">input</span>[<span class="dv">0</span>]),</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>            reorder_point_retailer<span class="op">=</span><span class="bu">round</span>(<span class="bu">input</span>[<span class="dv">1</span>]),</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            order_quantity_intermediate<span class="op">=</span>(<span class="bu">input</span>[<span class="dv">2</span>]),</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            reorder_point_intermediate<span class="op">=</span>(<span class="bu">input</span>[<span class="dv">3</span>]),</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            order_quantity_small_retailer<span class="op">=</span>(<span class="bu">input</span>[<span class="dv">4</span>]),</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            reorder_point_small_retailer<span class="op">=</span><span class="bu">round</span>(<span class="bu">input</span>[<span class="dv">5</span>])</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">## for the intermediate agent, we really only care about the money it accumulated</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        profits <span class="op">=</span> results[<span class="dv">1</span>].money <span class="op">+</span> results[<span class="dv">1</span>].currentInventory</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">### sum of total cash - all the stockouts penalties!</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> retailer <span class="kw">in</span> results[<span class="dv">2</span>]:</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            profits <span class="op">+=</span> profit_quick(retailer)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> small_retailer <span class="kw">in</span> results[<span class="dv">3</span>]:</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            profits <span class="op">+=</span> profit_quick(small_retailer)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        all_profits.append(<span class="op">-</span>profits)</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(all_profits)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="co">## start the optimization!</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> DiscreteHillClimbing <span class="im">import</span> Hill_Climbing_descent</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>available_predictors_values <span class="op">=</span> [</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="op">-</span><span class="dv">1</span>, <span class="dv">101</span>),</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    np.arange(<span class="op">-</span><span class="dv">1</span>, <span class="dv">501</span>)] <span class="op">*</span> <span class="dv">3</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>solution, value <span class="op">=</span> Hill_Climbing_descent(function <span class="op">=</span> fixed_reorder_run_ga,</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    available_predictors_values <span class="op">=</span> available_predictors_values,</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    random_counts_by_predictors <span class="op">=</span> <span class="dv">3</span>,</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    greedy_step <span class="op">=</span> <span class="dv">1</span>,</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    max_function_evals <span class="op">=</span> <span class="dv">500</span>,</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    maximize <span class="op">=</span> <span class="va">False</span>,</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    start_solution <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    seed <span class="op">=</span> <span class="dv">0</span>)  </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we run the optimizer, we get as a suggestions: <span class="math inline">\(s_{\text{Retailer}}=17, s_{\text{intermediate}}=13, s_{\text{Small Retailer}}=47\)</span> and <span class="math inline">\(Q_{\text{Retailer}}=47, Q_{\text{intermediate}}=99, Q_{\text{Small Retailer}}=76\)</span> which over 10 years results in profits of <span class="math inline">\(918,010\$\)</span>.<br>
This is very close to the maximum profits of <span class="math inline">\(927,132\$\)</span> which you’d get by plugging in the formula from above for each firm.</p>
<p>In general the rule makes sense, small retailers (who take a long time to receive their products) hold on to much larger inventories and make big orders which in turn forces the intermediary to keep large reserves as well. And we got this result by running an optimizer over this “agent-based model” rather than learning any math.</p>
<p>We can look at how the model runs (after 3,000 steps):</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="slice0_demo_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>You can see, particularly how small retailers need to order large batches and maintain large inventories since it takes a long time to receiver their products.</p>
<p>The thing that usually make supply chain interesting from an agent-based perspective is sensitivity analysis: what if an agent decides to start ordering a bit more to be “safe” (increases <span class="math inline">\(Q\)</span> or <span class="math inline">\(s\)</span>)? It turns out that it makes the system worse for everyone else.</p>
<p>Here I run the scenario where small retailers order 45 units at each order versus one where agents look for “additional safety” by ordering 100 at a time.<br>
In a single agent problem, ordering more increases your holding costs but here it causes actually retailrs to be worse off and often being left empty.<br>
This happens because of stockouts to the intermediary</p>
<div class="cell">
<div class="cell-output-display">
<p><img src="slice0_demo_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
</section>
<section id="future-steps" class="level1">
<h1>Future steps</h1>
<p>This was a long and rambling demo, reproducing the kind of results that anybody who dealt with supply chain learns in a couple of minutes.</p>
<p>It is however also the only way to build a model of which we can have any confidence: it must replicate obvious stuff before we make it do cool things.<br>
Now the important thing is to start adding interesting stuff:</p>
<ul>
<li>Item perishability (hello foodwaste)</li>
<li>LIFO and FIFO inventories (norms of what kind of “freshness” we expect when we buy stuff)</li>
<li>Learning and over-reactions (bullwhip effects are an old idea; but what do they mean for food waste?)</li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>